name: Devin Action
description: |
  Triggers a Devin.ai session with a given prompt or playbook. Optimized for use directly or as a response to slash commands.
branding:
  icon: cpu
  color: purple

inputs:
  comment-id:
    description: "Comment ID (optional, for reply chaining and context)"
    required: false
  issue-number:
    description: "Issue number (optional, for context)"
    required: false
  playbook-macro:
    description: "Playbook macro (optional, for structured workflows) - should start with '!' (e.g., !my_playbook)"
    required: false
  prompt-text:
    description: "Additional prompt text (optional)"
    required: false
  devin-token:
    description: "Devin API Token (required for authentication). For v1 API: Personal API Key (apk_user_*) or Service API Key (apk_*). For v3 API: Service User credential (cog_*)"
    required: true
  github-token:
    description: "GitHub Token (required for posting comments and accessing repo context)"
    required: false
  start-message:
    description: "Message to include in the start comment"
    required: false
    default: "ü§ñ **Starting Devin AI session...**"
  tags:
    description: "Additional tags to apply to the Devin session (supports CSV or line-delimited format). Automatic tags are always added: gh-actions-trigger and playbook-{macro-name} if playbook-macro is provided"
    required: false
  dry-run:
    description: "If 'true', the action will simulate the process without making an actual API call to Devin"
    required: false
    default: "false"
  api-version:
    description: "API version to use: 'v1' (default) or 'v3'. v3 requires org-id and uses service user credentials"
    required: false
    default: "v1"
  org-id:
    description: "Organization ID (required for v3 API). Can be found in Devin organization settings"
    required: false
  bypass-approval:
    description: "If 'true', bypass approval for batch session creation (v3 API batch mode only). Requires UseDevinExpert permission"
    required: false
    default: "false"
  advanced-mode:
    description: "Advanced execution mode (v3 API only). Available modes: 'batch' (start multiple sessions), 'analyze' (analyze sessions), 'create' (create playbook), 'improve' (improve playbook), 'manage' (manage knowledge)"
    required: false
  child-playbook-id:
    description: "Playbook ID for child sessions (required for 'batch' and 'improve' advanced modes)"
    required: false

runs:
  using: "composite"
  steps:

    - name: Build Devin prompt
      id: build-prompt
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        # Initialize prompt components
        prompt_parts=()

        # Add comment context if comment-id is provided
        if [[ -n "${{ inputs.comment-id }}" ]]; then
          echo "Fetching comment context..."
          COMMENT_JSON=$(gh api repos/${{ github.repository }}/issues/comments/${{ inputs.comment-id }})
          comment_body=$(echo $COMMENT_JSON | jq -r .body)
          comment_author=$(echo $COMMENT_JSON | jq -r .user.login)

          prompt_parts+=("Comment from @${comment_author}: ${comment_body}")

          # Add PR response instruction when comment-id is provided
          pr_response_instruction="IMPORTANT: The user will expect a response posted back to the PR. You should post exactly one comment back to the respective issue PR. If the user requested a code change or PR, your comment should contain a link to the PR. Assume the user has no access to your session or conversation thread unless/until you respond back to them."
          prompt_parts+=("$pr_response_instruction")
        fi

        # Add issue context if issue-number is provided
        if [[ -n "${{ inputs.issue-number }}" ]]; then
          echo "Fetching issue context..."
          ISSUE_JSON=$(gh api repos/${{ github.repository }}/issues/${{ inputs.issue-number }})
          issue_title=$(echo $ISSUE_JSON | jq -r .title)
          issue_author=$(echo $ISSUE_JSON | jq -r .user.login)
          issue_url="https://github.com/${{ github.repository }}/issues/${{ inputs.issue-number }}"

          prompt_parts+=("Issue #${{ inputs.issue-number }} by @${issue_author}: ${issue_title}")
          prompt_parts+=("Issue URL: ${issue_url}")
        fi

        # Add playbook macro reference if playbook-macro is provided
        if [[ -n "${{ inputs.playbook-macro }}" ]]; then
          prompt_parts+=("Please use playbook macro: ${{ inputs.playbook-macro }}")
        fi

        # Add custom prompt text if provided
        if [[ -n "${{ inputs.prompt-text }}" ]]; then
          echo "üëÄ Found 'prompt-text' input"
          prompt_parts+=("${{ inputs.prompt-text }}")
        else
          echo "üëÄ No 'prompt-text' input found"
        fi

        echo "üëÄ Combining all ${#prompt_parts[@]} prompt parts"
        if [[ ${#prompt_parts[@]} -eq 0 ]]; then
          echo "Error: No prompt content provided. At least one of comment-id, issue-number, playbook-macro, or prompt-text must be specified."
          exit 1
        fi

        # Join prompt parts with newlines
        final_prompt=""
        for part in "${prompt_parts[@]}"; do
          if [[ -n "$final_prompt" ]]; then
            final_prompt="${final_prompt}\n\n${part}"
          else
            final_prompt="$part"
          fi
        done

        echo "Final prompt built successfully"
        echo "::group::üìù Devin Prompt Preview"
        echo -e "$final_prompt"
        echo "::endgroup::"

        # Save prompt to output (properly escaped for safe YAML/JSON processing)
        # Use base64 encoding to safely handle any special characters including quotes
        echo "prompt<<EOF" >> $GITHUB_OUTPUT
        echo -n "$final_prompt" | base64 | tr -d '\n' >> $GITHUB_OUTPUT
        echo >> $GITHUB_OUTPUT  # Add newline before EOF
        echo "EOF" >> $GITHUB_OUTPUT

        # Also save a human-readable version for debugging
        echo "prompt_readable<<EOF" >> $GITHUB_OUTPUT
        echo -e "$final_prompt" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate run link
      id: vars
      shell: bash
      run: echo "run-url=https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID" >> "$GITHUB_OUTPUT"

    - name: Post job start comment
      if: inputs.comment-id || inputs.issue-number
      uses: peter-evans/create-or-update-comment@v4
      id: comment-start
      with:
        token: ${{ inputs.github-token }}
        comment-id: ${{ inputs.comment-id }}
        issue-number: ${{ inputs.issue-number }}
        body: |
          > ${{ inputs.start-message || 'ü§ñ **Starting Devin AI session...**' }}
          >

    - name: Create Devin session
      id: devin-session
      shell: bash
      env:
        DEVIN_TOKEN: ${{ inputs.devin-token }}
      run: |
        set -euo pipefail

        echo "Creating Devin session..."

        # Decode the base64-encoded prompt to handle special characters safely
        decoded_prompt=$(echo "${{ steps.build-prompt.outputs.prompt }}" | base64 -d || { echo "Error: Failed to decode base64 prompt"; exit 1; })

        # Build automatic tags
        automatic_tags=("gh-actions-trigger")

        # Add playbook tag if playbook-macro is provided
        if [[ -n "${{ inputs.playbook-macro }}" ]]; then
          # Extract macro name (remove leading ! if present)
          macro_name="${{ inputs.playbook-macro }}"
          macro_name="${macro_name#!}"  # Remove leading ! if present
          automatic_tags+=("playbook-${macro_name}")
        fi

        # Process additional tags input if provided (supports both CSV and line-delimited)
        additional_tags=()
        if [[ -n "${{ inputs.tags }}" ]]; then
          # Handle both CSV and line-delimited formats
          # First split by newlines, then by commas for each line
          while IFS= read -r line; do
            if [[ -n "$line" ]]; then
              # Split line by commas
              IFS=',' read -ra tag_array <<< "$line"
              for tag in "${tag_array[@]}"; do
                # Trim whitespace and add non-empty tags
                trimmed_tag=$(echo "$tag" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                if [[ -n "$trimmed_tag" ]]; then
                  additional_tags+=("$trimmed_tag")
                fi
              done
            fi
          done <<< "${{ inputs.tags }}"
        fi

        # Combine automatic and additional tags
        all_tags=("${automatic_tags[@]}" "${additional_tags[@]}")

        # Convert to JSON array
        tags_array=$(printf '%s\n' "${all_tags[@]}" | jq -R . | jq -s .)

        # Determine API version and endpoint
        api_version="${{ inputs.api-version }}"
        org_id="${{ inputs.org-id }}"
        bypass_approval="${{ inputs.bypass-approval }}"
        advanced_mode="${{ inputs.advanced-mode }}"
        child_playbook_id="${{ inputs.child-playbook-id }}"

        if [[ "$api_version" == "v3" ]]; then
          # Validate org-id is provided for v3 API
          if [[ -z "$org_id" ]]; then
            echo "Error: org-id is required when using v3 API"
            exit 1
          fi
          api_endpoint="https://api.devin.ai/v3beta1/organizations/${org_id}/sessions"
          echo "Using v3 API endpoint: $api_endpoint"

          # Validate child_playbook_id is provided for batch/improve modes
          if [[ "$advanced_mode" == "batch" || "$advanced_mode" == "improve" ]] && [[ -z "$child_playbook_id" ]]; then
            echo "Error: child-playbook-id is required when using advanced-mode '$advanced_mode'"
            exit 1
          fi

          # Build v3 API request payload with additional parameters
          jq -n \
            --arg prompt "$decoded_prompt" \
            --argjson tags "$tags_array" \
            --argjson bypass_approval "$(if [[ "$bypass_approval" == "true" ]]; then echo true; else echo false; fi)" \
            --arg advanced_mode "$advanced_mode" \
            --arg child_playbook_id "$child_playbook_id" \
            '{
              "prompt": $prompt,
              "tags": $tags
            } + (if $advanced_mode != "" then {"advanced_mode": $advanced_mode} else {} end)
              + (if $advanced_mode == "batch" and $bypass_approval then {"bypass_approval": true} else {} end)
              + (if $child_playbook_id != "" then {"child_playbook_id": $child_playbook_id} else {} end)' > devin_request.json
        else
          # v1 API (default)
          api_endpoint="https://api.devin.ai/v1/sessions"
          echo "Using v1 API endpoint: $api_endpoint"

          # Prepare the v1 API request payload using jq to properly escape JSON
          jq -n \
            --arg prompt "$decoded_prompt" \
            --arg repo_url "https://github.com/${{ github.repository }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repository "${{ github.repository }}" \
            --argjson tags "$tags_array" \
            '{
              "prompt": $prompt,
              "repository_url": $repo_url,
              "branch": $branch,
              "tags": $tags,
              "metadata": {
                "github_run_id": $run_id,
                "github_repository": $repository,
                "triggered_by": "github_action"
              }
            }' > devin_request.json
        fi

        echo "::group::üì§ Devin API Request"
        cat devin_request.json | jq
        echo "::endgroup::"

        if [[ "${{ inputs.dry-run }}" == 'true' ]]; then
          echo "üëÄ Dry run enabled, exiting early before making API call"
          echo "üëÄ Request payload:"
          cat devin_request.json | jq
          exit 0
        fi

        # Make API call to Devin
        response=$(curl -s -X POST \
          -H "Authorization: Bearer ${DEVIN_TOKEN}" \
          -H "Content-Type: application/json" \
          -d @devin_request.json \
          "$api_endpoint" || echo "API_CALL_FAILED")

        if [[ "$response" == "API_CALL_FAILED" ]]; then
          echo "Failed to call Devin API"
          exit 1
        fi

        echo "::group::üì• Devin API Response"
        echo "$response" | jq
        echo "::endgroup::"

        # Extract session information
        session_id=$(echo "$response" | jq -r '.session_id // .id // empty')
        session_url=$(echo "$response" | jq -r '.session_url // .url // empty')

        if [[ -z "$session_id" ]]; then
          echo "Failed to extract session ID from Devin API response"
          exit 1
        fi

        echo "Devin session created successfully!"
        echo "Session ID: $session_id"
        echo "Session URL: $session_url"

        echo "session-id=$session_id" >> $GITHUB_OUTPUT
        echo "session-url=$session_url" >> $GITHUB_OUTPUT

    - name: Append success comment
      if: steps.comment-start.outputs.comment-id && success()
      uses: peter-evans/create-or-update-comment@v4
      with:
        token: ${{ inputs.github-token }}
        comment-id: ${{ steps.comment-start.outputs.comment-id }}
        reactions: hooray
        body: |
          > - üîó **Session URL:** ${{ steps.devin-session.outputs.session-url }}
          >
          > ‚úÖ **Devin AI session created successfully!**

    - name: Append failure comment
      if: failure() && steps.comment-start.outputs.comment-id
      uses: peter-evans/create-or-update-comment@v4
      with:
        token: ${{ inputs.github-token }}
        comment-id: ${{ steps.comment-start.outputs.comment-id }}
        reactions: confused
        body: |
          > ‚ùå **Failed to create Devin AI session.**
          >
          > - ‚öôÔ∏è [Link to job logs.](${{ steps.vars.outputs.run-url }})
          >
          > **Please check the logs for details.**
