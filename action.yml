name: Devin Action
description: |
  Triggers a Devin.ai session with a given prompt or playbook. Optimized for use directly or as a response to slash commands.
branding:
  icon: cpu
  color: purple

inputs:
  comment-id:
    description: "Comment ID (optional, for reply chaining and context)"
    required: false
  issue-number:
    description: "Issue number (optional, for context)"
    required: false
  playbook-macro:
    description: "Playbook macro (optional, for structured workflows) - should start with '!' (e.g., !my_playbook)"
    required: false
  prompt-text:
    description: "Additional prompt text (optional)"
    required: false
  devin-token:
    description: "Devin API Token (required for authentication)"
    required: true
  github-token:
    description: "GitHub Token (required for posting comments and accessing repo context)"
    required: false
  start-message:
    description: "Message to include in the start comment"
    required: false
    default: "ðŸ¤– **Starting Devin AI session...**"
  tags:
    description: "Additional tags to apply to the Devin session (supports CSV or line-delimited format). Automatic tags are always added: gh-actions-trigger and playbook-{macro-name} if playbook-macro is provided. Cannot be used with session-id."
    required: false
  session-id:
    description: "Existing Devin session ID to inject a message into (optional). When provided, sends a message to an existing session instead of creating a new one. Mutually exclusive with 'tags' input."
    required: false
  dry-run:
    description: "If 'true', the action will simulate the process without making an actual API call to Devin"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:

    - name: Validate inputs
      shell: bash
      run: |
        set -euo pipefail

        # Check mutual exclusivity: session-id cannot be used with tags
        if [[ -n "${{ inputs.session-id }}" && -n "${{ inputs.tags }}" ]]; then
          echo "::error::The 'session-id' and 'tags' inputs are mutually exclusive. When injecting a message into an existing session, tags cannot be specified."
          exit 1
        fi

        echo "Input validation passed"

    - name: Build Devin prompt
      id: build-prompt
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        # Initialize prompt components
        prompt_parts=()

        # Add comment context if comment-id is provided
        if [[ -n "${{ inputs.comment-id }}" ]]; then
          echo "Fetching comment context..."
          COMMENT_JSON=$(gh api repos/${{ github.repository }}/issues/comments/${{ inputs.comment-id }})
          comment_body=$(jq -r .body <<< "$COMMENT_JSON")
          comment_author=$(jq -r .user.login <<< "$COMMENT_JSON")

          prompt_parts+=("Comment from @${comment_author}: ${comment_body}")

          # Add PR response instruction when comment-id is provided
          pr_response_instruction="IMPORTANT: The user will expect a response posted back to the PR. You should post exactly one comment back to the respective issue PR. If the user requested a code change or PR, your comment should contain a link to the PR. Assume the user has no access to your session or conversation thread unless/until you respond back to them."
          prompt_parts+=("$pr_response_instruction")
        fi

        # Add issue context if issue-number is provided
        if [[ -n "${{ inputs.issue-number }}" ]]; then
          echo "Fetching issue context..."
          ISSUE_JSON=$(gh api repos/${{ github.repository }}/issues/${{ inputs.issue-number }})
          issue_title=$(jq -r .title <<< "$ISSUE_JSON")
          issue_author=$(jq -r .user.login <<< "$ISSUE_JSON")
          issue_url="https://github.com/${{ github.repository }}/issues/${{ inputs.issue-number }}"

          prompt_parts+=("Issue #${{ inputs.issue-number }} by @${issue_author}: ${issue_title}")
          prompt_parts+=("Issue URL: ${issue_url}")
        fi

        # Add playbook macro reference if playbook-macro is provided
        if [[ -n "${{ inputs.playbook-macro }}" ]]; then
          prompt_parts+=("Please use playbook macro: ${{ inputs.playbook-macro }}")
        fi

        # Add custom prompt text if provided
        if [[ -n "${{ inputs.prompt-text }}" ]]; then
          echo "ðŸ‘€ Found 'prompt-text' input"
          prompt_parts+=("${{ inputs.prompt-text }}")
        else
          echo "ðŸ‘€ No 'prompt-text' input found"
        fi

        echo "ðŸ‘€ Combining all ${#prompt_parts[@]} prompt parts"
        if [[ ${#prompt_parts[@]} -eq 0 ]]; then
          echo "Error: No prompt content provided. At least one of comment-id, issue-number, playbook-macro, or prompt-text must be specified."
          exit 1
        fi

        # Join prompt parts with actual newlines (using $'\n' for real newlines)
        final_prompt=""
        for part in "${prompt_parts[@]}"; do
          if [[ -n "$final_prompt" ]]; then
            final_prompt="${final_prompt}"$'\n\n'"${part}"
          else
            final_prompt="$part"
          fi
        done

        echo "Final prompt built successfully"
        echo "::group::ðŸ“ Devin Prompt Preview"
        printf '%s\n' "$final_prompt"
        echo "::endgroup::"

        # Save prompt to output (properly escaped for safe YAML/JSON processing)
        # Use base64 encoding to safely handle any special characters including quotes
        echo "prompt<<EOF" >> $GITHUB_OUTPUT
        printf '%s' "$final_prompt" | base64 | tr -d '\n' >> $GITHUB_OUTPUT
        echo >> $GITHUB_OUTPUT  # Add newline before EOF
        echo "EOF" >> $GITHUB_OUTPUT

        # Also save a human-readable version for debugging
        echo "prompt_readable<<EOF" >> $GITHUB_OUTPUT
        printf '%s\n' "$final_prompt" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate run link
      id: vars
      shell: bash
      run: echo "run-url=https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID" >> "$GITHUB_OUTPUT"

    - name: Post job start comment
      if: inputs.comment-id || inputs.issue-number
      uses: peter-evans/create-or-update-comment@v4
      id: comment-start
      with:
        token: ${{ inputs.github-token }}
        comment-id: ${{ inputs.comment-id }}
        issue-number: ${{ inputs.issue-number }}
        body: |
          > ${{ inputs.start-message || 'ðŸ¤– **Starting Devin AI session...**' }}
          >

    - name: Create Devin session or inject message
      id: devin-session
      shell: bash
      env:
        DEVIN_TOKEN: ${{ inputs.devin-token }}
      run: |
        set -euo pipefail

        # Decode the base64-encoded prompt to handle special characters safely
        decoded_prompt=$(echo "${{ steps.build-prompt.outputs.prompt }}" | base64 -d || { echo "Error: Failed to decode base64 prompt"; exit 1; })

        # Check if we're injecting into an existing session or creating a new one
        if [[ -n "${{ inputs.session-id }}" ]]; then
          # ===== INJECT MESSAGE INTO EXISTING SESSION =====
          session_id="${{ inputs.session-id }}"
          session_url="https://app.devin.ai/sessions/${session_id}"

          echo "Injecting message into existing Devin session..."
          echo "Session ID: $session_id"
          echo "Session URL: $session_url"

          # Prepare the message API request payload
          jq -n \
            --arg message "$decoded_prompt" \
            '{
              "message": $message
            }' > devin_request.json

          echo "::group::ðŸ“¤ Devin Message API Request"
          cat devin_request.json | jq
          echo "::endgroup::"

          if [[ "${{ inputs.dry-run }}" == 'true' ]]; then
            echo "ðŸ‘€ Dry run enabled, exiting early before making API call"
            echo "ðŸ‘€ Request payload:"
            cat devin_request.json | jq
            echo "session-id=$session_id" >> $GITHUB_OUTPUT
            echo "session-url=$session_url" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Make API call to send message to existing session
          response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
            -H "Authorization: Bearer ${DEVIN_TOKEN}" \
            -H "Content-Type: application/json" \
            -d @devin_request.json \
            "https://api.devin.ai/v1/sessions/${session_id}/message")

          # Extract HTTP status code
          http_status=$(echo "$response" | grep "HTTP_STATUS:" | cut -d':' -f2)
          response_body=$(echo "$response" | sed '/HTTP_STATUS:/d')

          echo "::group::ðŸ“¥ Devin API Response"
          echo "HTTP Status: $http_status"
          echo "$response_body" | jq . 2>/dev/null || echo "$response_body"
          echo "::endgroup::"

          if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
            echo "Message injected successfully into Devin session!"
            echo "session-id=$session_id" >> $GITHUB_OUTPUT
            echo "session-url=$session_url" >> $GITHUB_OUTPUT
          else
            echo "::error::Failed to inject message into Devin session. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi

        else
          # ===== CREATE NEW SESSION =====
          echo "Creating new Devin session..."

          # Build automatic tags
          automatic_tags=("gh-actions-trigger")

          # Add playbook tag if playbook-macro is provided
          if [[ -n "${{ inputs.playbook-macro }}" ]]; then
            # Extract macro name (remove leading ! if present)
            macro_name="${{ inputs.playbook-macro }}"
            macro_name="${macro_name#!}"  # Remove leading ! if present
            automatic_tags+=("playbook-${macro_name}")
          fi

          # Process additional tags input if provided (supports both CSV and line-delimited)
          additional_tags=()
          if [[ -n "${{ inputs.tags }}" ]]; then
            # Handle both CSV and line-delimited formats
            # First split by newlines, then by commas for each line
            while IFS= read -r line; do
              if [[ -n "$line" ]]; then
                # Split line by commas
                IFS=',' read -ra tag_array <<< "$line"
                for tag in "${tag_array[@]}"; do
                  # Trim whitespace and add non-empty tags
                  trimmed_tag=$(echo "$tag" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                  if [[ -n "$trimmed_tag" ]]; then
                    additional_tags+=("$trimmed_tag")
                  fi
                done
              fi
            done <<< "${{ inputs.tags }}"
          fi

          # Combine automatic and additional tags
          all_tags=("${automatic_tags[@]}" "${additional_tags[@]}")

          # Convert to JSON array
          tags_array=$(printf '%s\n' "${all_tags[@]}" | jq -R . | jq -s .)

          # Prepare the API request payload using jq to properly escape JSON
          jq -n \
            --arg prompt "$decoded_prompt" \
            --arg repo_url "https://github.com/${{ github.repository }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repository "${{ github.repository }}" \
            --argjson tags "$tags_array" \
            '{
              "prompt": $prompt,
              "repository_url": $repo_url,
              "branch": $branch,
              "tags": $tags,
              "metadata": {
                "github_run_id": $run_id,
                "github_repository": $repository,
                "triggered_by": "github_action"
              }
            }' > devin_request.json

          echo "::group::ðŸ“¤ Devin API Request"
          cat devin_request.json | jq
          echo "::endgroup::"

          if [[ "${{ inputs.dry-run }}" == 'true' ]]; then
            echo "ðŸ‘€ Dry run enabled, exiting early before making API call"
            echo "ðŸ‘€ Request payload:"
            cat devin_request.json | jq
            exit 0
          fi

          # Make API call to Devin
          response=$(curl -s -X POST \
            -H "Authorization: Bearer ${DEVIN_TOKEN}" \
            -H "Content-Type: application/json" \
            -d @devin_request.json \
            "https://api.devin.ai/v1/sessions" || echo "API_CALL_FAILED")

          if [[ "$response" == "API_CALL_FAILED" ]]; then
            echo "Failed to call Devin API"
            exit 1
          fi

          echo "::group::ðŸ“¥ Devin API Response"
          echo "$response" | jq
          echo "::endgroup::"

          # Extract session information
          session_id=$(echo "$response" | jq -r '.session_id // .id // empty')
          session_url=$(echo "$response" | jq -r '.session_url // .url // empty')

          if [[ -z "$session_id" ]]; then
            echo "Failed to extract session ID from Devin API response"
            exit 1
          fi

          echo "Devin session created successfully!"
          echo "Session ID: $session_id"
          echo "Session URL: $session_url"

          echo "session-id=$session_id" >> $GITHUB_OUTPUT
          echo "session-url=$session_url" >> $GITHUB_OUTPUT
        fi

    - name: Append success comment
      if: steps.comment-start.outputs.comment-id && success()
      uses: peter-evans/create-or-update-comment@v4
      with:
        token: ${{ inputs.github-token }}
        comment-id: ${{ steps.comment-start.outputs.comment-id }}
        reactions: hooray
        body: |
          > - ðŸ”— **Session URL:** ${{ steps.devin-session.outputs.session-url }}
          >
          > âœ… **Devin AI session ${{ inputs.session-id != '' && 'message sent' || 'created' }} successfully!**

    - name: Append failure comment
      if: failure() && steps.comment-start.outputs.comment-id
      uses: peter-evans/create-or-update-comment@v4
      with:
        token: ${{ inputs.github-token }}
        comment-id: ${{ steps.comment-start.outputs.comment-id }}
        reactions: confused
        body: |
          > âŒ **Failed to ${{ inputs.session-id != '' && 'send message to' || 'create' }} Devin AI session.**
          >
          > - âš™ï¸ [Link to job logs.](${{ steps.vars.outputs.run-url }})
          >
          > **Please check the logs for details.**
